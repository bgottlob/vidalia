= Vidalia
== What is Vidalia?

Vidalia uses layers to simplify the creation and maintenance of API and database calls in your automated test suite.  

A typical automated test suite can be broken down into layers:

* A <b>workflow layer</b> on top, which dictates the user's path through the application.  Think in terms of verbs and user stories: "As a user, when I create a new message, I expect it to be sent to the desired recipient."  The workflow layer cares about user actions and results, not about the mechanics of entering or retrieving data.
* A <b>control layer</b> beneath, which defines the specific interactions with the application.  This control layer would be implemented using API calls or direct database calls and cares only about getting data into and out of the application.

Vidalia allows for easy separation of the workflow and control layers by sitting between them.  At the control layer, it provides a simple infrastructure for creation and maintenance of API/database calls.  At the workflow layer, it provides a set of basic test directives, allowing for easier manipulation of data without having to worry about the details of the underlying interfaces.

== How does Vidalia work?

At the control layer, Parfait allows you to define three basic artifacts: Interfaces, Objects, and Elements

=== Interface

An Interface is the top layer of the Vidalia artifact hierarchy.  It is simply a collection of Objects.

=== Object

An Object is a collection of data elements that can be manipulated via the defined Interface.  Basic Object operations (e.g. create, read, update, delete) or more complex ones can be defined by the user.

==== Object operations

Operations can be added for an Object to communicate via the Interface.  In some cases, the operation will retrieve data via the interface.  In others the operation will create or alter data via the interface.

=== Element

An Element is a single piece of data within an Object.  All Elements have a set of directives associated with them to enable easier implementation of your test automation.

==== Element Directives

Manipulation and verification of each data Element is built around the two primary directives +get+ and +set+:

- +get+ - reads and returns the current value of the Element from the Object.  Usually performed after data is retreived via an Object operation.
- +set+ - updates the current value of the Element in preparation for the next operation on the Object.

Once these primary directives are defined, Vidalia puts them together to build the following directives for free:

- +retrieve+ - Reads and returns the current value from the Element.  Does not log anything.  (This is the user-callable version of +get+.)
- +update+ - Sets a new Element value.  Logs the value of the Element both before and after the change for auditing purposes.
- +confirm+ - Tests the value of the Element, returning +true+ if the input matches the value of the Element and +false+ otherwise.  Does not log anything.
- +verify+  = Tests the value of the Element, raising an exception if the input does not match the value of the Element.  Returns +true+ otherwise.  Logs successes for auditing purposes.

== How do I install Vidalia?

Install the Vidalia gem from the command line as follows:

  $ gem install vidalia

== How do I get started with Vidalia?

The code examples used below are all taken from the Vidalia repository in the +examples/example1+ directory.  In this directory, we will be automating control of user data in the database defined with by the +db_helper.rb+ script.

Remember, Vidalia breaks the code into two layers, so we'll define those layers in different files.  The workflow layer will be defined in +demo.rb+, but let's start by using Parfait to define the control layer in +user_object.rb+.

=== Define the Interface

Our first step is to define an Interface.  If the interface has already been defined elsewhere, that definition will be returned.  This allows multiple Object definitions (in multiple files) to be added to the same Interface.

  app_db = Vidalia::Interface.define(:name => "Application DB")

=== Define our Object

Now we can define our object.  Since we're working with a user entry in our database, we'll name it "User".  The definition will indicate that the Object's parent is our Interface.  Additionally, the Object definition will contain a code block to be run whenever this Object is instantiated.  A typical Object definition block will instantiate object variables.

  user_object = Vidalia::Object.define(:name => "User", :parent => app_db) {
    singleton_class.class_eval { attr_accessor :id }
    @id = nil
    singleton_class.class_eval { attr_accessor :first_name }
    @first_name = nil
    singleton_class.class_eval { attr_accessor :last_name }
    @last_name = nil
    singleton_class.class_eval { attr_accessor :username }
    @username = nil
  }

=== Define Object operations

In our example, we will define operations to create, retrieve, update, and delete a User object.  Note that the use of Objects and Elements will be different depending on the type of operation.  To prepare for a "retrieve" operation, the user will set whatever elements are needed to perform the retrieval, after which the operation will be called.  To perform an "create" operation, all impacted Elements must be set before the creation.

Let's start with "create":

  user_object.add_method(:name => "create") {
    db = SQLite3::Database.open "users.db"
    sql_string = "INSERT INTO users VALUES("
    sql_string << @id.to_s
    sql_string << ","
    sql_string << @first_name.to_s
    sql_string << ","
    sql_string << @last_name.to_s
    sql_string << ","
    sql_string << @username.to_s
    sql_string << ")"
    Vidalia.log("Adding a user with DB call \"#{sql_string}\"")
    db.execute sql_string
    db.close
  }

As described above, this operation expects all of the pertinent Elements to already be set.  The operation itself just performs a single database operation to create the new Object.

Next we define a "read" operation:

  user_object.add_method(:name => "read") { |inhash|
    db = SQLite3::Database.open "users.db"
    if inhash[:id] 
      sql_string = "SELECT * FROM users WHERE id = #{inhash[:id]};"
      Vidalia.log("Reading user ID=#{inhash[:id]} with DB call \"#{sql_string}\"")
    elsif inhash[:username]
      sql_string = "SELECT * FROM users WHERE username = #{inhash[:username]};"
      Vidalia.log("Reading user username=#{inhash[:username]} with DB call \"#{sql_string}\"")
    end
    results = db.execute sql_string
  
    # Handle empty array
    results << [nil,nil,nil,nil] if results.size == 0
  
    result = results[0]
    @id = result.shift
    @first_name = result.shift
    @last_name = result.shift
    @username = result.shift
    db.close
  }

Note that this operation doesn't require any Element data to be pre-set.  It will overwrite whatever is stored in the Object with the data returned from the database call.

The "update" operation is similar to "create" in that Element data is already expected to be defined for this operation:

user_object.add_method(:name => "update") {
  db = SQLite3::Database.open "users.db"
  sql_string = "Update users SET first_name=\'"
  sql_string << @first_name.to_s
  sql_string << "\', last_name=\'"
  sql_string << @last_name.to_s
  sql_string << "\', username=\'"
  sql_string << @username.to_s
  sql_string << "\' WHERE id="
  sql_string << @id.to_s
  sql_string << ";"
  Vidalia.log("Updating user ID=#{@id} with DB call \"#{sql_string}\"")
  db.execute sql_string
  db.close
}

And "delete" requires just an Element or two to accomplish its goal:

  user_object.add_method(:name => "delete") { |inhash|
    db = SQLite3::Database.open "users.db"
    if inhash[:id] 
      sql_string = "DELETE FROM users WHERE id = #{inhash[:id]};"
      Vidalia.log("Deleting user ID=#{inhash[:id]} with DB call \"#{sql_string}\"")
    elsif inhash[:username]
      sql_string = "DELETE * FROM users WHERE username = #{inhash[:username]};"
      Vidalia.log("Deleting user username=#{inhash[:username]} with DB call \"#{sql_string}\"")
    end
    db.execute sql_string
    db.close
  }

Finally, we will complete the Object definition by telling Vidalia how to set and get each Element value.  To do this, we have to define the Element objects:

  id_element = Vidalia::Element.define(:name => "ID", :parent => user_object) 
  id_element.add_get { |opts|
    @parent.id
  }
  id_element.add_set { |value|
    @parent.id = value
  }

For the most part, Element definitions will be this simple.  Just name them, associate them with their parent Object, and specify the "get" and "set" directives.  With the +get+ and +set+ directives defined, Vidalia will use them to build +update+, +retrieve+, +confirm+, and +verify+ directives for you.  We'll use those in the workflow layer in a bit.

We need three more Elements to complete our example:

  first_name_element = Vidalia::Element.define(:name => "First Name", :parent => user_object) 
  first_name_element.add_get { |opts|
    @parent.first_name
  }
  first_name_element.add_set { |value|
    @parent.first_name = value
  }


  last_name_element = Vidalia::Element.define(:name => "Last Name", :parent => user_object) 
  last_name_element.add_get { |opts|
    @parent.last_name
  }
  last_name_element.add_set { |value|
    @parent.last_name = value
  }


  username_element = Vidalia::Element.define(:name => "Username", :parent => user_object) 
  username_element.add_get { |opts|
    @parent.username
  }
  username_element.add_set { |value|
    @parent.username = value
  }


And now our Object declaration is complete!  Now on to the workflow layer.

=== Invoke the Workflow

$$$ I STOPPED HERE $$$

To define the workflow layer, let's edit +demo.rb+.  First we need to require Watir and Parfait:

  require 'watir-webdriver'
  require 'parfait'
  
Next we want to include our page definition.

  require './page'

Then we can set up the browser, go to the sample page, and tell Parfait about it.  You'll want to adjust the directory here as necessary.

  browser = Watir::Browser.new
  browser.goto "file://#{ENV['HOME']}/git/parfait/examples/example1/index.html"
  
  Parfait::set_browser(browser)

Before we start using our directives, we also need to pass a logging routine to Parfait.  This routine just tells Parfait how to log a given string.  For our demonstration, we'll just print to stdout:

  Parfait::set_logroutine { |logstring|
    puts logstring
  }

And finally, let's get the Application we defined in +page.rb+ saved into an object:

  app = Parfait::Application.find("Sample App")

Now we can invoke directives!  With all the setup behind us, it's now pretty straightforward to manipulate the controls on this page.  Let's start by setting our party:

  app.page("Sample Page").control("Party").update "Republicrat"

Note that the logging for that call indicates both what the control contained previously as well as what it has been set to.  

Also, remember that under the covers, for any call taking action on +page("Sample Page")+, Parfait is using the +present+ directive to confirm that the page is still visible before continuing.

Any of the directives will work on this control.  If we want to verify that it is set as we requested, we can do that as well:

  app.page("Sample Page").control("Party").verify "Republicrat"

We can submit our change using the "Set My Party" button:

  app.page("Sample Page").control("Set My Party").navigate

Using the Region we defined, we can also easily manipulate controls within the table.  To change the nickname for John Adams, we can just target his table entry like this:

  app.page("Sample Page").region("President" => "John Adams").control("Nickname").update "Sammy's Bro"

Similarly, we can verify his nickname:

  app.page("Sample Page").region("President" => "John Adams").control("Nickname").verify "Sammy's Bro"

We can also use our Region to navigate to the biography for Thomas Jefferson:

  app.page("Sample Page").region("President" => "Thomas Jefferson").control("Biography").navigate

This is a simple example, but hopefully it demonstrates the power and flexibility Parfait gives you in managing controls and using them in the workflow layer of your test automation.

